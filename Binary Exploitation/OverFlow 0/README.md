# OverFlow 0
This should be easy. Overflow the correct buffer in this [program](vuln) and get a flag. Its also found in /problems/overflow-0_5_db665826dabb99c44758c97abfd8c4c6 on the shell server. [Source](vuln.c).

## Hint
Find a way to trigger the flag to print
If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.

## Solution
The source code contains the following line
```
signal(SIGSEGV, sigsegv_handler);
```
We see that the man page of the `signal` function states that `signal` takes in a `signum` and a `handler`. An excerpt:
```
*  If the disposition is set to SIG_DFL, then the default action associated with the signal (see signal(7)) occurs.
*  If  the  disposition  is set to a function, then first either the disposition is reset to SIG_DFL, or the signal is blocked... and then handler is called with argument signum.
```
It seems that, by default, `signal` is called with the `SIG_DFL` disposition. However, the vuln program is attaching the function `sigsegv_handler` to the `SIGSEGV` signum, which will be called instead of the default disposition, presumeably raising the "Segmentation Fault" error. We also see that `sigsegv_handler` prints the flag into stderr:
```fprintf(stderr, "%s\n", flag);```
This means our goal is to cause a segmentation violation signal (SIGSEGV), which will call the sigsegv_handler and print the flag. Segmentation faults can occur in various ways, one simple way being to jump to an invalid value in memory. This is the premise behind a buffer overflow: by "overflowing" the area in memory with some bytes, we can overwrite the instruction pointer saved on the stack (when the main function was called) and jump to somewhere else in memory instead of the one saved. We can do this because the program reads the arguments we pass in with `strcpy` - a function that doesn't check the size of the input and only terminates when a NULL (\x00) character is reached. Our payload will look like this:
```./vuln $(python -c "import struct; print 'a'*132+struct.pack('I', 0xdeadc0de)")```
Note: `struct.pack('I', 0xdeadc0de)` is simply indicating the saved eip that will be overwritten. Any string of characters, as long as it is larger than 132 bytes and changes the saved the eip, will cause a segfault.

## Details
Completed: *During challenge*  
Points: **100**  
Done by: Cyril  
Flag: `picoCTF{3asY_P3a5y4a888b8e}`
